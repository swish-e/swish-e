<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
  <head>
   <title>SWISH-Enhanced:  SWISH-CONFIG - Configuration File Directives </title>
   <link href="./style.css" rel=stylesheet type="text/css" title="refstyle">
  </head>
  <body>

    <h1 class="banner">
        <img src="images/swish.gif" alt="Swish-E Logo"><br>
        <img src="images/swishbanner1.gif"><br>
        <img src="images/dotrule1.gif"><br>
         SWISH-CONFIG - Configuration File Directives 
    </h1>

    <hr>

    <p>
    <div class="navbar">
      <a href="./SWISH-RUN.html">Prev</a> |
      <a href="./index.html">Contents</a> |
      <a href="./SWISH-SEARCH.html">Next</a>
    </div>
    <p>

    <div class="toc">
      
<A NAME="toc"></A>
<P><B>Table of Contents:</B></P>

<UL>

	<LI><A HREF="#SWISH_E_CONFIGURATION_FILE">SWISH-E CONFIGURATION FILE</A>
	<UL>

		<LI><A HREF="#Alphabetical_Listing">Alphabetical Listing</A>
		<LI><A HREF="#Administrative_Headers_Directive">Administrative Headers Directives</A>
		<LI><A HREF="#Document_Source_Directives">Document Source Directives</A>
		<LI><A HREF="#Document_Contents_Directives">Document Contents Directives</A>
		<LI><A HREF="#Document_Filter_Directives">Document Filter Directives</A>
		<LI><A HREF="#Directives_for_the_File_Access_m">Directives for the File Access method only</A>
		<LI><A HREF="#Directives_for_the_HTTP_Access_M">Directives for the HTTP Access Method Only</A>
	</UL>

	<LI><A HREF="#Document_Info">Document Info</A>
</UL>

    </div>

    

	    [ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>

<P>
<H1><A NAME="SWISH_E_CONFIGURATION_FILE">SWISH-E CONFIGURATION FILE</A></H1>
<P>
What files SWISH-E indexes and how they are indexed, and where the index is
written can be controlled by a configuration file. The configuration file
is passed to swish as a command line argument by using the <CODE>-f</CODE> switch (see <A HREF="././SWISH-RUN.html">SWISH-RUN</A>).

<P>
The configuration file is a text file composed of comments, blank lines,
and <STRONG>configuration directives</STRONG>. Order of the directives is not important. Some directives may be used
more than once in the configuration file, while others can only be used
once (e.g. additional directives will overwrite preceding directives). Case
of the directive is not important -- you may use upper, lower, or mixed
case.

<P>
Comments and directives currently must start at column 1 in the
configuration file. Comments are any line that beging with a ``#''.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # This is a comment</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Typically, configuration file the directives are grouped together in some
logical order -- that is, directives that control the source of the
documents would be grouped together first, and directives that control how
each document is filtered or its words index in another group of
directives. (The directives listed below are grouped in this order). You
may also split your directives up into different configuration files and
specify more than one configuration file when running swish-e from the
command line. This allows you to have a master configuration file used for
many different indexes, and smaller configuration files for each separate
index.

<P>
Some command line arguments can override directives specified in the
configuration file. Please see also the <A HREF="././SWISH-RUN.html">SWISH-RUN</A> for instructions on running SWISH-E, and the <A HREF="././SWISH-SEARCH.html">SWISH-SEARCH</A> page for information and examples on how to search your index.

<P>
A commented example configuration file is included in the <EM>config</EM> directory of the SWISH-E distribution.

<P>
The configuration file is specified to SWISH-E by the <CODE>-c</CODE> switch. For example,

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    swish-e -c myconfig.conf</pre>
        </td>
	    
      </tr>
    </table>
    <P>
The configuration file directives are listed below in these groups:    

<UL>
<P><LI>
<P>
<A HREF="#Administrative_Headers_Directive">Administrative Headers Directives</A> -- You may add administrative information to the header of the index file.

<P><LI>
<P>
<A HREF="#Document_Source_Directives">Document Source Directives</A> -- Directives for selecting the source documents and the location of the
index file.

<P><LI>
<P>
<A HREF="#Document_Contents_Directives">Document Contents Directives</A> -- Directives that control how a document content is indexed.

<P><LI>
<P>
<A HREF="#Directives_for_the_File_Access_m">Directives for the File Access method only</A> -- These directives are only applicable to the File Access indexing method.

<P><LI>
<P>
<A HREF="#Directives_for_the_HTTP_Access_M">Directives for the HTTP Access Method Only</A> -- Likewise, these only apply to the HTTP Access method.

</UL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Alphabetical_Listing">Alphabetical Listing</A></H2>
<P>
I'm not sure why this should be here -- I added it to look for missing
directives. How do I get pod2html to create Name tags for items below?

<UL>
<P><LI>
<P>
BeginCharacters <CODE>*string</CODE> of characters*

<P><LI>
<P>
BumpPositionCounterCharacters *string*

<P><LI>
<P>
DefaultContents [TXT|HTML|XML] <CODE>*file</CODE> extensions*

<P><LI>
<P>
Delay *seconds*

<P><LI>
<P>
EndCharacter <CODE>*string</CODE> of characters*

<P><LI>
<P>
EquivalentServer <CODE>*server</CODE> alias*

<P><LI>
<P>
FileInfoCompression [yes|no]

<P><LI>
<P>
FileRules [contains|is] <CODE>*regular</CODE> expression*

<P><LI>
<P>
FollowSymLinks [yes|no]

<P><LI>
<P>
IgnoreFirstChar <CODE>*string</CODE> of characters*

<P><LI>
<P>
IgnoreLastChar <CODE>*string</CODE> of characters*

<P><LI>
<P>
IgnoreLimit <CODE>*integer</CODE> integer*

<P><LI>
<P>
IgnoreTotalWordCountWhenRanking [yes|no]

<P><LI>
<P>
IgnoreWords <CODE>*list</CODE> of stop words*

<P><LI>
<P>
IndexAdmin *text*

<P><LI>
<P>
IndexComments [0|1]

<P><LI>
<P>
IndexDescription *text*

<P><LI>
<P>
IndexDir [URL|directories or files]

<P><LI>
<P>
IndexFile *path*

<P><LI>
<P>
IndexName *text*

<P><LI>
<P>
IndexOnly <CODE>*list</CODE> of file suffixes*

<P><LI>
<P>
IndexPointer *text*

<P><LI>
<P>
IndexReport [0|1|2|3]

<P><LI>
<P>
MaxDepth *integer*

<P><LI>
<P>
MaxWordLimit *integer*

<P><LI>
<P>
MetaNames <CODE>*list</CODE> of names*

<P><LI>
<P>
MinWordLimit *integer*

<P><LI>
<P>
NoContents <CODE>*list</CODE> of file suffixes*

<P><LI>
<P>
OkNoMeta [yes|no]

<P><LI>
<P>
PropertyNames <CODE>*list</CODE> of meta names*

<P><LI>
<P>
ReplaceRules [replace|remove|prepend|append]

<P><LI>
<P>
ReqMetaName [yes|no]

<P><LI>
<P>
SpiderDirectory *path*

<P><LI>
<P>
StoreDescription [XML &lt;tag&gt;|HTML &lt;meta&gt;|TXT size]

<P><LI>
<P>
TmpDir *path*

<P><LI>
<P>
TranslateCharacters <CODE>*string1</CODE> string2*

<P><LI>
<P>
UseStemming [yes|no]

<P><LI>
<P>
WordCharacters <CODE>*string</CODE> of characters*

</UL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Administrative_Headers_Directive">Administrative Headers Directives</A></H2>
<P>
SWISH-E stores configuration information in the header of the index file.
This information can be retrieved while searching or by functions in the
SWISH-E C library. There are a number of fields available for your own use.
None of these fields are required:

<DL>
<P><DT><STRONG><A NAME="item_IndexName">IndexName *text*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_IndexDescription">IndexDescription *text*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_IndexPointer">IndexPointer *text*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_IndexAdmin">IndexAdmin *text*</A></STRONG><DD>
<P>
These variables specify information that goes into index files to help
users and administrators. IndexName should be the name of your index, like
a book title. IndexDescription is a short description of the index or a URL
pointing to a more full description. IndexPointer should be a pointer to
the original information, most likely a URL. IndexAdmin should be the name
of the index maintainer and can include name and email information. These
values should not be more than 70 or so characters and should be contained
in quotes. Note that the automatically generated date in index files is in
D/M/Y and 24-hour format. 

<P>
Examples:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IndexName &quot;Linux Documentation&quot;
    IndexDescription &quot;This is an index of /usr/doc on our Linux machine.&quot; 
    IndexPointer &quot;<A HREF="http://localhost/swish/linux/index.html&quot">http://localhost/swish/linux/index.html&quot</A>;
    IndexAdmin &quot;webmaster&quot;</pre>
        </td>
	    
      </tr>
    </table>
    </DL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Document_Source_Directives">Document Source Directives</A></H2>
<P>
These directives control <EM>what</EM> documents are indexed. See also
<A HREF="#Directives_for_the_File_Access_m">Directives for the File Access method only</A>
and
<A HREF="#Directives_for_the_HTTP_Access_M">Directives for the HTTP Access Method Only</A>
for directives that are specific to those access methods. 

<DL>
<P><DT><STRONG><A NAME="item_IndexDir">IndexDir [URL|directories or files]</A></STRONG><DD>
<P>
IndexDir defines the source of the documents for SWISH-E. SWISH-E currently
supports two file access methods: <STRONG>File system</STRONG> and <STRONG>HTTP</STRONG> (also called <STRONG>spidering</STRONG>). The <CODE>-S</CODE> command line argument is used to select the file access method.

<P>
For the <STRONG>File system</STRONG> method of access <STRONG>IndexDir</STRONG> is a space-separated list of files and directories to index. You may
specify more than one <STRONG>IndexDir</STRONG> directive.

<P>
Any sub-directories of any listed directory will also be indexed.

<P>
Examples:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # Index this directory an any subdirectories
    IndexDir /usr/local/home/http</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # Index the docs directory in current directory
    IndexDir ./docs</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # Index these files in the current directory
    IndexDir ./index.html ./page1.html ./page2.html
    # and index this directory, too
    IndexDir ../public_html
    </pre>
        </td>
	    
      </tr>
    </table>
    <P>
For the <STRONG>HTTP</STRONG> method of access specify the URL's from which you want the spidering to
begin.

<P>
Example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IndexDir <A HREF="http://www.my-site.com/index.html">http://www.my-site.com/index.html</A>
    IndexDir <A HREF="http://localhost/index.html">http://localhost/index.html</A></pre>
        </td>
	    
      </tr>
    </table>
    <P>
Obviously, using the <STRONG>HTTP</STRONG> method to index is <STRONG>much</STRONG> slower than indexing local files. Be well aware that some sites do not
appreciate spidering and may block your IP address. You may wish to contact
the remote site before spidering their web site. More information about
spidering can be found in <A HREF="#Directives_for_the_HTTP_Access_M">Directives for the HTTP Access Method Only</A> below.

<P><DT><STRONG><A NAME="item_IndexFile">IndexFile *path*</A></STRONG><DD>
<P>
Index file specifies the location of the generated index file. If not
specified, SWISH-E will create the file <EM>index.swish-e</EM> in the current directory.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IndexFile /usr/local/swish/site.index</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_FollowSymLinks">FollowSymLinks [yes|no]</A></STRONG><DD>
<P>
Put ``yes'' to follow symbolic links in indexing, else ``no''. Default is
no.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    FollowSymLinks no
    FollowSymLinks yes</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_ReplaceRules">ReplaceRules [replace|remove|prepend|append]</A></STRONG><DD>
<P>
ReplaceRules allows you to make changes to file pathnames before they're
indexed. These changed file names or URLs will be returned in search
results.

<P>
For example, you may index your files locally (with the File system
indexing method), yet return a URL in search results. This directive can be
used to map the file names to their respective URLs on your web server.

<P>
There are four operations you can specify: <STRONG>replace</STRONG>, <STRONG>append</STRONG>, <STRONG>remove</STRONG>, and <STRONG>prepend</STRONG>. They will parse the pathname in the order you've typed these commands.
More than one command and its arguments can appear on the same line, but
it's easier to read when commands are broken up over a few lines. You can't
put a command and its <CODE>argument(s)</CODE> on different lines, however.

<P>
This directive uses C library regex.h regular expressions.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   replace &quot;the string you want replaced&quot; &quot;what to change it to&quot;
        This replaces all occurrences of the old string
        with the new one.</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   remove &quot;a string to remove&quot;   </pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   prepend &quot;a string to add before the result&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>   append &quot;a string to add after the result&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Examples:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    ReplaceRules replace &quot;testdir/&quot; &quot;anotherdir/&quot;
    ReplaceRules replace &quot;[a-z_0-9]*_m.*\.html&quot; &quot;index.html&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    ReplaceRules remove &quot;testdir/&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    ReplaceRules prepend &quot;<A HREF="http://localhost/&quot">http://localhost/&quot</A>;
    ReplaceRules append &quot;.html&quot;</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_IndexReport">IndexReport [0|1|2|3]</A></STRONG><DD>
<P>
This is how detailed you want reporting while indexing. You can specify
numbers 0 to 3 - 0 is totally silent, 3 is the most verbose. The default is
3, so you probably should define this.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IndexReport 1</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This may be overridden from the command line via the <CODE>-v</CODE> switch (see <A HREF="././SWISH-RUN.html">SWISH-RUN</A>).

<P><DT><STRONG><A NAME="item_IndexContents">IndexContents [TXT|HTML|XML]  *file extensions*</A></STRONG><DD>
<P>
Swish knows how to parse TXT, HTML, and XML documents. This directive maps
file extensions to those types of parsers.

<P>
Example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IndexContents HTML .htm .html .shtml
    IndexContents TXT  .txt .log .text</pre>
        </td>
	    
      </tr>
    </table>
    <P>
<STRONG>Note:</STRONG> This may be changed in the future to use content-types. See <A HREF="././SWISH-3.0.html">SWISH-3.0</A>



<P><DT><STRONG><A NAME="item_DefaultContents">DefaultContents [TXT|HTML|XML]</A></STRONG><DD>
<P>
This sets the default parser for documents that are not specified in <STRONG>IndexContents</STRONG>



<P>
Example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    DefaultContents HTML</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_FileInfoCompression">FileInfoCompression [yes|no]</A></STRONG><DD>
<P>
Setting <STRONG>FileInfoCompression</STRONG> to <CODE>yes</CODE> will compress the index file to save disk space. This may result in longer
indexing times. The default is <CODE>no</CODE>.

<P>
Also see the <CODE>-e</CODE> switch in <A HREF="././SWISH-RUN.html">SWISH-RUN</A> for saving RAM during indexing.

</DL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Document_Contents_Directives">Document Contents Directives</A></H2>
<P>
These directives control what information is extracted from your source
documents, and how that information is made available during searching.

<DL>
<P><DT><STRONG><A NAME="item_MetaNames">MetaNames *list of names*</A></STRONG><DD>
<P>
Meta names can be used to limit searches to parts of your documents (see
also the <CODE>-t</CODE> switch below). This allow you to define keywords or special fields within
your documents and then limit searches to those areas of your documents.
The <STRONG>MetaNames</STRONG> is a space separated list:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MetaNames meta1 meta2 keywords subjects</pre>
        </td>
	    
      </tr>
    </table>
    <P>
If you use the special word <STRONG>automatic</STRONG> then SWISH-E will automatically locate any meta names in your document.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MetaNames automatic</pre>
        </td>
	    
      </tr>
    </table>
    <P>
This option should not be used in XML documents.

<P>
META tags can have three formats in your source documents:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;META NAME=&quot;meta1&quot; CONTENT=&quot;some content&quot;&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;!-- META START NAME=&quot;meta1&quot; --&gt;
        some content
    &lt;!-- META END --&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
And in XML format

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;meta1&gt;
        Some Content
    &lt;/meta1&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Then you can limit your search to just META <STRONG>meta1</STRONG> like this:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    swish-e -w 'meta1=(apples or oranges)'</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You may nest the XML and the start/end tag versions:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;keywords&gt;
        &lt;tag1&gt;
            some content
        &lt;/tag1&gt;
        &lt;tag2&gt;
            some other content
        &lt;/tag2&gt;
    &lt;keywords&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Then you can search in both tag2 and tag2 with:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>  swish-e -w 'keywords=(query words)'</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_OkNoMeta">OkNoMeta [yes|no]</A></STRONG><DD>
<P>
If <STRONG>OkNoMeta</STRONG> is set to <CODE>yes</CODE> (the default) then any meta tag contents found in the document that is not
defined in the <STRONG>MetaNames</STRONG> directive will be indexed, but the tag contents will be added to the <EM>main index</EM> and not to any meta name. In other words, the words of the meta tag will be
indexed as if the words were part of the body of the document, and not
within a meta tag. If <STRONG>OkNoMeta</STRONG> is set to <CODE>no</CODE> then SWISH-E will halt indexing with an error if a META tag is detected
that is not listed in the MetaNames directive. This can be helpful to catch
misspelled Meta names or names that you did not anticipate.

<P><DT><STRONG><A NAME="item_ReqMetaName">ReqMetaName [yes|no]</A></STRONG><DD>
<P>
The above behavior of OkNoMeta can be modified by the <STRONG>ReqMetaName</STRONG> directive. If this setting is defined as <CODE>yes</CODE> then any META tag found in the document that is <EM>not</EM>
listed in MetaNames will simply be ignored and not indexed. This is helpful
if you have meta data in your source documents that you do not want to
index. The default is <CODE>no</CODE>, so the entire document is indexed.

<P><DT><STRONG><A NAME="item_PropertyNames">PropertyNames *list of meta names*</A></STRONG><DD>
<P>
SWISH-E allows you to specify certain META tags that can be used as <STRONG>document properties</STRONG>. The contents of any META tag that has been identified as a document
property can be returned as part of the search results along with the rank,
file name, title, and document size (see the <CODE>-p</CODE> switch in <A HREF="././SWISH-RUN.html">SWISH-RUN</A>).

<P>
Properties are useful for returning additional data from documents in
search results -- this saves the effort of reading and parsing the source
files while reading SWISH-E search results, and is especially useful when
the source documents are no longer available.

<P>
SWISH-E can also use the PropertyNames for sorting the search results (see
the <CODE>-s</CODE> switch).

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    PropertyNames author subjects</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Note that the PropertyNames listed must also be listed in the MetaNames
directive. Property names are case insensitive.

<P>
Use of PropertyNames will increase the size of your index file, sometimes
significantly.

<P><DT><STRONG><A NAME="item_StoreDescription">StoreDescription [XML &lt;tag&gt; size|HTML &lt;meta&gt; size|TXT size]</A></STRONG><DD>
<P>
<STRONG>StoreDescription</STRONG> allows you to store a document description in the index file, and this
description is returned in your search results when the <CODE>-x</CODE> switch is used for extended results.

<P>
For text documents you specify the type <CODE>TXT</CODE> and the number of characters to capture.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    StoreDescription TXT 20</pre>
        </td>
	    
      </tr>
    </table>
    <P>
For HTML, and XML file types, specify the the tag to use for the
description, and optionally the number of characters to capture. If not
specified will capture the entire contents of the tag.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    StoreDescription HTML &lt;body&gt; 20
    StoreDescription XML  &lt;desc&gt; 40
 
=item UseStemming [yes|no]</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Put yes to apply word stemming algorithm during indexing, else no. 

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    UseStemming no
    UseStemming yes</pre>
        </td>
	    
      </tr>
    </table>
    <P>
When UseStemming is set to <CODE>yes</CODE> every word is stemmed before placing it in to the index.    

<P>
The stemming function does not convert words to their root, rather
programmatically removes endings on words in an attempt to make similar
words with different endings stem to the same string of characters. It's
not a perfect system, and searches on stemmed indexes often return curious
results. For example, two entirely different words may stem to the same
word.

<P>
Stemming also can be confusing when used with a wildcard (truncation). For
example, you might expect to find the word ``running'' by searching for
``runn*''. But this fails when using a stemmed index, as ``running'' stems
to ``run'', yet searching for ``runn*'' looks for words that start with
``runn''.

<P>
It's a good idea to create both a stemmed and non-stemmed index and allow
your search interface select which index to use.

<P><DT><STRONG><A NAME="item_IgnoreTotalWordCountWhenRanking">IgnoreTotalWordCountWhenRanking [yes|no]</A></STRONG><DD>
<P>
Put yes to ignore the total number of words in the file when calculating
ranking. Often better with merges and small files. Default is no.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IgnoreTotalWordCountWhenRanking yes</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_MinWordLimit">MinWordLimit *integer*</A></STRONG><DD>
<P>
Set the minimum length of an word. Shorter words will not be indexed. The
default is 1 (as defined in <EM>src/config.h</EM>).

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MinWordLimit 5</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_MaxWordLimit">MaxWordLimit *integer*</A></STRONG><DD>
<P>
Set the maximum length of an indexable word. Every longer word will not be
indexed. The Default is 40 (as defined in <EM>src/config.h</EM>).

<P><DT><STRONG><A NAME="item_WordCharacters">WordCharacters *string of characters*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_IgnoreFirstChar">IgnoreFirstChar *string of characters*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_IgnoreLastChar">IgnoreLastChar *string of characters*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_BeginCharacters">BeginCharacters *string of characters*</A></STRONG><DD>
<P><DT><STRONG><A NAME="item_EndCharacter">EndCharacter *string of characters*</A></STRONG><DD>
<P>
These settings define what a word consists of to the SWISH-E indexing
engine. Compiled in defaults are in <EM>src/config.h</EM>.

<P>
When indexing SWISH-E uses <STRONG>WordCharacters</STRONG> to split up the document into words. Words are defined by any string of
non-blank characters that contain only the characters listed in
WordCharacters. If a string of characters includes a character that is not
in WordCharacters then the word will be spit into two or more separate
words.

<P>
For example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    WordCharacters abde</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Would turn ``abcde'' into two words ``ab'' and ``de''.

<P>
Next, of these words, any characters defined in <STRONG>IgnoreFirstChar</STRONG> are stripped off the start of the word, and <STRONG>IgnoreLastChar</STRONG> characters are stripped off the end of the word. This allows, for example,
periods within a word (www.slashdot.com), but not at the end of a word.
Characters in IgnoreFirstChar and IgnoreLastChar must be in WordCharacters.

<P>
Finally, the resulting words MUST begin with one of the characters listed
in <STRONG>BeginCharacters</STRONG> and end with one of the characters listed in <STRONG>EndCharacters</STRONG>. BeginCharacters and EndCharacters must be a subset of the characters in
WordCharacters. Often, WordCharacters, BeginCharactes and EndCharacters
will all be the same.

<P>
Note that the same process applies to the query while searching.

<P>
Getting these setting correct will take careful consideration and practice.
It's helpful to create an index of a single test file, and then look at the
words that are placed in the index (see the <CODE>-D</CODE> and <CODE>-k</CODE> searching switches).

<P>
Currently there is only support for eight-bit characters.

<P>
Example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    WordCharacters  .abcdefghijklmnopqrstuvwxyz
    BeginCharacters abcdefghijklmnopqrstuvwxyz
    EndCharacters   abcdefghijklmnopqrstuvwxyz
    IgnoreFirstChar .
    IgnoreLastChar  .</pre>
        </td>
	    
      </tr>
    </table>
    <P>
So the string

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    Please visit <A HREF="http://www.example.com/path/to/file.html.">http://www.example.com/path/to/file.html.</A></pre>
        </td>
	    
      </tr>
    </table>
    <P>
will be indexed as the following words:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    please
    visit
    http
    www.example.com
    path
    to
    file.html</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Which means that you can search for <CODE>www.example.com</CODE> as a single word, but searching for just <CODE>example</CODE> will not find the document.

<P>
Note: when indexing HTML documents HTML entities are converted to their
character equivalents before being processed with these directives. This is
a change from previous versions of SWISH-E where you were required to
include the characters <CODE>0123456789&amp;#;</CODE> to index entities.

<P>
<STRONG>XXX FIX -- 2.1.10-devel6 still required the &</STRONG>



<P>
If indexing any characters that have special meaning to SWISH ``*'' ``=''
``('' and ``)'', test carefully how they can be accessed and searched. For
example, ``='' may be used in a query but only if backslashed, where ``(''
and ``)'' can be indexed but not searched (currently).

<P><DT><STRONG><A NAME="item_IgnoreWords">IgnoreWords *list of stop words*</A></STRONG><DD>
<P>
The IgnoreWords option allows you to specify words to ignore. Comment out
for no stopwords; the word ``SwishDefault'' will include a list of default
stopwords. Words should be separated by spaces and may span multiple
directives. If the special format <CODE>File:filename</CODE> is used then the stop words will be read from an external file during
indexing.

<P>
Examples:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IgnoreWords www http a an the of and or</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IgnoreWords SwishDefault</pre>
        </td>
	    
      </tr>
    </table>
    <P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IgnoreWords <A HREF="File:./stopwords.de">File:./stopwords.de</A></pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_IgnoreLimit">IgnoreLimit *integer integer*</A></STRONG><DD>
<P>
This automatically omits words that appear too often in the files (these
words are called stopwords). Specify a whole percentage and a number, such
as ``80 256''. This omits words that occur in over 80% of the files and
appear in over 256 files. Comment out to turn of auto-stopwording.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IgnoreLimit 50 1000</pre>
        </td>
	    
      </tr>
    </table>
    <P>
SWISH-E must do extra processing to adjust the entire index when this
feature is used. It is recommended that instead of using this feature that
you decided what words are stop words and add them to <STRONG>IngoreWords</STRONG> in your configuration file. To do this, use IgnoreLimit one time and note
the stop words that are found while indexing. Add this list to IgnoreWords,
and then remove IgnoreLimit from the configuration file.

<P><DT><STRONG><A NAME="item_IndexComments">IndexComments [0|1]</A></STRONG><DD>
<P>
This option allows the user decide if to index the HTML comments. Default
is 1. Set to 0 if comment indexing is not required.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    IndexComments 0</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_TranslateCharacters">TranslateCharacters *string1 string2*</A></STRONG><DD>
<P>
The TranslateCharacters directive maps the characters in string1 to the
characters listed in string2. This is done after htnl entities are
converted but before words are defined by WordCharacters.

<P>
For example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # This will index a_b as a-b and ámo as amo
    TranslateCharacters _á -a</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_BumpPositionCounterCharacters">BumpPositionCounterCharacters *string*</A></STRONG><DD>
<P>
When indexing SWSIH-E assigns a word position to each word. This allows for
phrase searching. There may be cases where you would like to prevent phrase
matching. The BumpPositionCounterCharacters directive allows you to specify
a set of characters that when found in the text will increment the word
position -- effectively preventing phrase matches across that character.

<P>
For example, if you have a META tag:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    &lt;!-- META START NAME=&quot;subjects&quot; --&gt;
        computer programming | apple computers
    &lt;!-- META END --&gt;</pre>
        </td>
	    
      </tr>
    </table>
    <P>
You might want to prevent matching ``programming apple'' in that meta name.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    BumpPositionCounterCharacters |</pre>
        </td>
	    
      </tr>
    </table>
    <P>
There is no default, and you may list a string of characters.

</DL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Document_Filter_Directives">Document Filter Directives</A></H2>
<P>
Internally, SWISH-E knows how to parse only text, HTML, and XML documents.
With SWISH-E filters you can index other types of documents. For example,
if all your web pages are in gzip format a filter can uncompress these on
the fly for indexing.

<P>
A filter is an external program that swish executes when processing a
document of a given type. SWISH-E will execute the filter program for each
file that matches the file extension set in the
<STRONG>FileFilter</STRONG> directive. SWISH-E calls the external program passing as arguments the file
path that swish is about to index, and optionally, the URL from the http
file source method.

<P>
The filter program must open the file, process its contents, and return it
to SWISH-E by printing to STDOUT.

<P>
Note that this can add a significant of time to the indexing process. If
you have many files to filter you should consider writing your filter in C
instead of a shell or perl script.

<P>
<STRONG>Note:</STRONG> Filtering in swish may change in the future (see <A HREF="././SWISH-3.0.html">SWISH-3.0</A>).

<DL>
<P><DT><STRONG><A NAME="item_FilterDir">FilterDir  *path-to-directory*</A></STRONG><DD>
<P>
This is the path to a directory where the filter programs are stored. Swish
looks in this directory to find the filter specified in the <STRONG>FileFilter</STRONG> directive.

<P>
Example:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    FilterDir /usr/local/swish/filters</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_FileFilter">FileFilter</A></STRONG><DD>
<P>
This maps file extensions to a filter program.

<P>
Examples:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    FileFilter  .pdf   pdf-filter.sh
    Filefilter  .gz    gzip-filter.sh
    Filefilter  .doc   wword-filter.sh
    Filefilter  .dot   wword-filter.sh
    Filefilter  .ps    ghostscript-filter.sh</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Here are some examples of filters.

<P>
Convert .pdf files to text:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    #!/bin/sh
    /usr/local/bin/pdftotext &quot;$1&quot; - 2&gt;/dev/null</pre>
        </td>
	    
      </tr>
    </table>
    <P>
Convert gzipped files to text:

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    #!/usr/local/bin/perl -w
    use strict;
    use Compress::Zlib ;
    
    my $file = $ARGV[1] || shift;
    
    die &quot;Usage: gzcat file...\n&quot;
        unless $file;
    
    my $gz = gzopen($file, 'rb')
        or die &quot;Cannot open $file: $gzerrno\n&quot; ;
    
    my $buffer;
    print $buffer
        while $gz-&gt;gzread($buffer) &gt; 0 ;
    
    die &quot;Error reading from $file: $gzerrno\n&quot;
        if $gzerrno != Z_STREAM_END ;
    
    $gz-&gt;gzclose() ;</pre>
        </td>
	    
      </tr>
    </table>
    </DL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Directives_for_the_File_Access_m">Directives for the File Access method only</A></H2>
<P>
Some directives have different uses depending on the source of the
documents. These directives are only valid when using the <STRONG>File system</STRONG> method of indexing.

<DL>
<P><DT><STRONG><A NAME="item_IndexOnly">IndexOnly *list of file suffixes*</A></STRONG><DD>
<P>
This directive specifies the allowable file suffixes (extensions) while
indexing. The default is to index all files specified in <STRONG>IndexDir</STRONG>.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    # Only index .html .htm and .q files
    IndexOnly .html .htm .q</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_NoContents">NoContents *list of file suffixes*</A></STRONG><DD>
<P>
Files with these suffixes will <STRONG>not</STRONG> have their contents indexed, but their file names will be indexed. File
names are not normally indexed. If you specify <CODE>.html</CODE> or <CODE>.htm</CODE> then if a &lt;TITLE&gt; section is found those words will be indexed,
otherwise the file name will be indexed.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    NoContents .gif .xbm .au .mov .mpg .pdf .ps</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_FileRules">FileRules [contains|is] *regular expression*</A></STRONG><DD>
<P>
Files matching the specified criteria will <STRONG>not</STRONG> be indexed. C regex.h library regular expression pattern matching is
allowed.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    FileRules pathname contains .*dir1
    FileRules filename contains # % ~ .bak .orig .old old.
    FileRules title contains construction example pointers
    FileRules directory contains .htaccess
    FileRules filename is index</pre>
        </td>
	    
      </tr>
    </table>
    </DL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H2><A NAME="Directives_for_the_HTTP_Access_M">Directives for the HTTP Access Method Only</A></H2>
<P>
These directives are available when using the HTTP Access Method of
indexing.

<DL>
<P><DT><STRONG><A NAME="item_MaxDepth">MaxDepth *integer*</A></STRONG><DD>
<P>
MaxDepth defines how many links the spider should follow before stopping. A
value of 0 configures the spider to traverse all links. The default is
MaxDepth 5.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    MaxDepth 5</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_Delay">Delay *seconds*</A></STRONG><DD>
<P>
The number of seconds to wait between issuing requests to a server. This
setting allows for more friendly spidering of remote sites. The default is
60 seconds.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    Delay 60</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_TmpDir">TmpDir *path*</A></STRONG><DD>
<P>
The location of a write-able temp directory on your system. The HTTP access
method tells the Perl helper to place its files in this location. The
default is /var/tmp.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    TmpDir /tmp/swish/</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_SpiderDirectory">SpiderDirectory *path*</A></STRONG><DD>
<P>
The location of the Perl helper script called <EM>swishspider</EM>. If you use a relative directory, it is relative to your directory when
you run SWISH-E, not to the directory that SWISH-E is in. The default is <CODE>./</CODE>



<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    SpiderDirectory /usr/local/swish/</pre>
        </td>
	    
      </tr>
    </table>
    <P><DT><STRONG><A NAME="item_EquivalentServer">EquivalentServer *server alias*</A></STRONG><DD>
<P>
Often times the same site may be referred to by different names. A common
example is that often <A
HREF="http://www.some-server.com">http://www.some-server.com</A> and <A
HREF="http://some-server.com">http://some-server.com</A> are the same. Each
line should have a list of all the method/names that should be considered
equivalent. Multiple EquivalentServer directives may be used. Each
directive defines its own set of equivalent servers.

<P>

    <table>
      <tr>

	<td bgcolor="#eeeeee" width="1">
	  &nbsp;
        </td>

	<td>
	  <pre>    EquivalentServer <A HREF="http://library.berkeley.edu">http://library.berkeley.edu</A> <A HREF="http://www.lib.berkeley.edu">http://www.lib.berkeley.edu</A>
    EquivalentServer <A HREF="http://sunsite.berkeley.edu:2000">http://sunsite.berkeley.edu:2000</A> <A HREF="http://sunsite.berkeley.edu">http://sunsite.berkeley.edu</A></pre>
        </td>
	    
      </tr>
    </table>
    </DL>
<P>
[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>
<H1><A NAME="Document_Info">Document Info</A></H1>
<P>
$Id$

<P>
.

[ <B><FONT SIZE=-1><A HREF="#toc">TOC</A></FONT></B> ]
<HR>



    <p>
    <div class="navbar">
      <a href="./SWISH-RUN.html">Prev</a> |
      <a href="./index.html">Contents</a> |
      <a href="./SWISH-SEARCH.html">Next</a>
    </div>
    <p>

    <P ALIGN="CENTER">
    <IMG ALT="" WIDTH="470" HEIGHT="10" SRC="images/dotrule1.gif"></P>
    <P ALIGN="CENTER">

    <div class="footer">
        Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000 Hewlett-Packard Company<BR>
        Originally by Kevin Hughes, kev@kevcom.com, March 11, 1994.
        <BR>SWISH-E is distributed with <B>no warranty</B> under the terms of the <A 
        HREF="http://www.fsf.org/copyleft/gpl.html">GNU Public License</A>,<BR>
        Free Software Foundation, Inc., 
        59 Temple Place - Suite 330, Boston, MA  02111-1307, USA<BR> 
        Public questions may be posted to 
        the <A HREF="http://sunsite.berkeley.edu/SWISH-E/Discussion/">SWISH-E Discussion</A>.
    </div>

</body>
</html>

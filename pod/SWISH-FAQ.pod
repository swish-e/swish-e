=head1 NAME

The SWISH-E FAQ - Answers to Common Questions

=head1 Frequently Asked Questions

=head2 What is SWISH-E?

SWISH-E is B<S>imple B<W>eb B<I>ndexing B<S>ystem for B<H>umans - B<E>nhanced.
With it, you can quickly and easily index directories of files or remote web sites and search the generated
indexes.

=head2 Swish crashes and burns on a certain file. What can I do? 

You can use a FileRules operation to exclude the particular file name, or pathname, or its title. If there are serious problems in indexing
certain types of files, they may not have valid text in them (they may be binary files, for instance). You can use NoContents to exclude that
type of file.

=head2 Swish isn't working and I can't solve the problem myself.

The SWISH-E discussion list is the place to go.  http://sunsite.berkeley.edu/SWISH-E/.

Before you post you might read the next question.  Also, be sure to include in the following when asking for help.

=over 4

=item * The swish-e version (./swish-e -V)

=item * What you are indexing (and perhaps a sample), and the number of files

=item * Your swish-e configuration file

=item * Any error messages that swish-e is reporting

=back

In addition, the utilities strace (or truss), and a backtrace from a debugger such as gdb
may provide valuable information.  This can be helpful in tracking down segfaults:

    % gdb /path/to/swish-e
    [now run with parameters that cause a segfault]
    (gdb) run -w foo -f index.file 
    (gdb) bt


=head2 Swish isn't indexing a certain word or phrase. 

By default, swish-e tries to make it best guesses as to what it thinks are reasonable words and filters out "garbage" words according to a set
of rules, for instance, if swish-e encounters a word that has no vowels, it doesn't index it. You can change these rules by editing the config.h
file in the src directory of the swish-e distribution package. By editing the rules, you may be able to index quite a few more words, or less,
depending on your preference.

Configuration file directives (L<SWISH-CONFIG|SWISH-CONFIG>)
C<WordCharacters>, C<BeginCharacters>, C<EndCharacters>,
C<IgnoreFirstChar>, and C<IgnoreLastChar> also control what words swish indexes.

Use of the command line arguments C<-k>, C<-v> and C<-D> are useful when debugging these issues.
Using C<-v 4> while indexing will display each word as it is indexed.  You should specify one file
when using this feature since it can generate a lot of output.

     ./swish-e -c my.conf -v 4 -i problem.file
     
You may also swish to index a single file that contains words that are or are not indexing as you expect
and use -D -v 4 to out debugging information about the index.  A useful command might be:

    ./swish-e -f index.swish-e -D -v 4 | grep -v ^0

The C<grep> command is used to filter out some of the output.

=head2 How can I index documents on a web server?

If possible, use the file system method C<-S fs> of indexing to index documents on your web server.
This avoids the overhead of spidering a web server.

If this is impossible (the web server is not local, or documents are dynamically generated), swish provides
two methods of spidering.  First, swish includes the http method of indexing C<-S http>. A number of
special configuration directives are available that control spidering
(see L<Directives for the HTTP Access Method Only|/"Directives for the HTTP Access Method Only">).
A perl helper script (swishspider.pl) is included in the C<src> directory to assist with spidering
web servers.

As of swish 2.2, there's a general purpose "prog" document source where a program can feed documents to
swish for indexing.  A number of example programs can be found in the C<prog-bin> directory, including
a program to spider web servers.  The provided spider.pl program is full-featured and is easily customized.

The advantage of the "prog" document source feature over the "http" method is that the program is only executed
one time, where the swishspider.pl program used in the "http" method is executed once for every document
read from the web server.  The forking of swish and compiling of the perl script can take quite expensive, time-wise.

The other advantage is that it's simple and efficient to add filtering (such as for PDF or MS Word docs)
right into the spider.pl's configuration.


=head2 How can I index all my compressed files?

Swish can make use of "filters" that will convert files such as MS Word documents, PDF, or gzipped files into text, HTML
or XML and can thus be indexed by SWISH-E.
Please see L<SWISH-CONFIG|SWISH-CONFIG/"Document Filter Directives"> and the example in the filter-bin
directory for more information.

Another option to use the "prog" document source input method.
You write a program (such as a perl script) that will convert your data as needed
and then output one of the formats that swish understands (currently, HTML, XML, and text).  Swish can call
this program and the program will pass on all documents to swish.


=head2 How can I index data from a database?

Use the "prog" document source method of indexing.  Write a program to extract out the data from your
database, and format it as XML, HTML, or text.  See the examples in the C<prog-bin> directory.

=head2 Can I index 8-bit text? 

Yes, you can. Just remember that swish-e retains capitalization for all characters other than [a-z A-Z], so the word "Çelik" is not retrieved by
"çelik", "Celik", or "celik". You can index and use words containing any entity from ! (#033) to ÿ (#255).

(note: but swish uses tolower(3), so locale settings may apply.)

Also, the TranslateCharacters directive (L<SWISH-CONFIG|SWISH-CONFIG>) can translate characters while indexing
and searching.  C<TranslateCharacters :ascii7:> is a predefined set of characters that will translate eight bit characters to ascii7 characters.
Using the :ascii7: rule will translate "Ääç" to "aac". This means: searching "Çelik", "çelik" or "celik"
will all match the same word.  


=head2 How can I index phrases? 

Phrases are indexed automatically.  To search for a phrase simply place double quotes around the phrase.

For example:

    swish-e -w 'free and "fast search engine"'

=head2 How can I prevent phrases from matching across sentences?

Use the L<BumpPositionCounterCharacters|/"item_BumpPositionCounterCharacters"> configuration
directive.


=head2 How can I implement keywords in my documents? 

In your HTML files you can put keywords in HTML META tags or in XML blocks.

META tags can have three formats in your source documents:

    <META NAME="DC.subject" CONTENT="digital libraries">

    <!-- META START NAME="meta1" -->
        some content
    <!-- META END -->

And in XML format

    <meta2>
        Some Content
    </meta2>


Then, to inform SWISH-E about the existence of the meta name in your documents,
edit the line in your configuration file:

    MetaNames DC.subject meta1 meta2


=head2 I run out of memory trying to index my files. 

It's true that indexing can take up a lot of memory!
One thing you can do is make many indices of smaller content instead of trying to do
everything at once. You can then merge all the smaller pieces together with the C<-M> switch, or use
the C<-f> switch to specify more than one index while searching.

Another option is use the C<-e> switch.  This will require less memory, but indexing will take longer as
not all data will be stored in memory while indexing.  Please report back your findings as it seems C<-e>
requires quite a bit less RAM, but often not that much more time.

=head2 I can't limit searches to title/body/comment.

Or, I<I can't search with meta names, all the names are indexed as "plain".>

Check in the config.h file if #define INDEXTAGS is set to 1. If it is, change it to 0, recompile, and index again. When INDEXTAGS is 1,
ALL the tags are indexed as plain text, that is you index "title", "h1", and so on, AND they loose their indexing meaning. If INDEXTAGS is
set to 0, you will still index meta tags and comments, unless you have indicated otherwise in the user config file with the IndexComments
directive.

Also, check for the C<UndefinedMetaTags> setting in your configuration file.

=head2 Do I need to reindex my site each time I upgrade to a new Swish-e version? 

At times it might not strictly be necessary, but since you don't really know if anything in the index has changed,
it is a good rule to reindex anyway. 

=head2 Can I index PDF or Winword documents with swish-e?

Swish-e can internally only handle HTML, WML, XML and TXT (text) files.
To index other document types you have to install a filter into swish-e using the FileFilter config directive.
These filters have to translate a document into the swish-e known formats (e.g. text or html). You can use
"xpdf" or "ghostscript" to convert pdf to text or e.g. "catdoc" to convert winword documents on unix.  
For details, please have a look on the filter configuration part, and look in the C<filter-bin> directory
of the SWISH-E distribution.

The other option, which may or may not be faster, is to use the "prog" document source method to supply filtered
documents to swish while indexing.  See the example in the C<prog-bin> directory.

=head2 Does swish include a CGI interface?

An example CGI script is included in the C<example> directory.
(Type C<perldoc swish.cgi> in the C<example> directory for instructions.)

Please be careful when picking a CGI script to use with swish.  Quite a few of the scripts
that have been available for swish are insecure and should not be used.

=head2 How do I make swish highlight words in search results?

Swish-e can't because it doesn't have access to the source documents when returning results,
of course.  But a front-end program of your creation can highlight terms.  Your program can open up the
source documents and then use regular expressions to replace search terms with highlighted or bolded
words.

But, that will fail with all but the most simple source documents.  For HTML documents, for example,
you must parse the doucment into words and tags (and comments).  A word you wish to highlight may span
mutilple HTML tags, or be a word in a URL and you wish to highlight the entire link text.

Perl modules such as HTML::Parser
and XML::Parser make word extraction possible.  Next, you need to consider that swish uses settings such as
WordCharacters, BeginCharacters, EndCharacters, IgnoreFirstChar, and IgnoreLast, char to define a
"word".  That is, you can't consider that a string of characters with white space on each side is a word.

Then things like TranslateCharacters, and HTML Entities may transform a source word into something else,
as far as swish is concerned.  Finally, searches can be limited by metanames, so you may need to
limit your highlighting to only parts of the source document.
Throw phrase searches and stopwords into the equation
and you can see that it's not a trivial problem to solve.

All hope is not lost, thought, as swish does provide some help.
Using the C<-H> option swish will return in the headers the current index (or indexes) settings
for WordCharacters (and others) required to parse your source documents as swish parses them during indexing,
and will return a "Parsed Words:" header that will show how swish parsed the query internally.
If you use word stemming then you will also need to stem each word in your document before comparing
with the "Parsed Words:" returned by swish.  The swish-e stemming code is available either by using
the swish-e Perl module or C library (included with the swish-e distribution), or by using the SWISH::Stemmer
module available on CPAN.

=head2 My system admin says swish uses too much of the CPU!

That's a good thing!  That expensive CPU is suppose to be busy.

Indexing takes a lot of work -- to make indexing fast much of the work is done in memory, and
moving all that memory around requires CPU time.  But, there's two things you can try:

The C<-e> option will run swish in economy mode, which uses the disk to store data while indexing.
This makes swish run somewhat slower, but also uses less memory.  Since swish is writing to disk more often
it will be spending more time waiting on I/O and less time in CPU.  Maybe.

The other thing is to simply lower the priority of the job using the nice(1) command:

    /bin/nice -15 swish-e -c search.conf

If concerned about searching time, make sure you are using the -b and -m switches to only return
a page at a time.  If you know that your result sets will be large, and that you wish to return results
one page at a time, and that often times many pages of the same query will be requested, you may be smart
to request all the documents on the first request, and then cache the results to a temporary file.  The
perl module File::Cache makes this very simple to accomplish.

=head2 How do I pass swish a list of files to index?

Currently, there is not a configuration directive to include a file that contains a list of files to index.
But, there is a directive to include another configuration file.

    IncludeConfigFile /path/to/other/config

And in C</path/to/other/config> you can say:

    IndexDir file1 file2 file3 file4 file5 ...
    IndexDir file20 file21 file22

You may also specify more than one configuration file on the command line:

    ./swish-e -c config_one config_two config_three

Another option is to create a directory with symbolic links of the files to index,
and index just that directory.


=head2 How do I use Swish-E on a Windows Server?

Install Linux?

=head2 Can I add/remove files from an index?

Not really.  Swish currently has no way to add or remove items from its index.

About the only way to delete items from the index is to stat(2) all the results to make sure that
all the files still exist.

Incremental additions can be handled in a couple of ways, depending on your situation.  It's probably
easiest to create one main index every night (or every week), and then create an index of just the new files
between main indexing jobs and use the C<-f> option to pass both indexes to swish while searching.

You can merge the indexes into one index (instead of using -f),
but it's not clear that this has any advantage over searching multiple indexes.  Using C<-f> gives
access to the individual headers of both indexes, while C<-M> merges the headers, and merging indexes with
different indexing settings (Stemming, WordCharacters) may produce odd results.
This is a question for the swish-e discussion list.

How does one create the incremental index?

One method is by using the C<-N> switch to pass a file path to swish when indexing.
Swish will only index files that have a last modificaiton date C<newer> than the file
supplied with the C<-N> switch.

This option has the disadvantage that swish must process every file in every directory
as if they were going to be indexed (the test for -N is done last right before indexing
of the file contents begin and after all other tests on the file have been completed)
-- all that just to find a few new files.
Also, if you use the swish index file as the file passed to -N there may be files
that were added after indexing was started, but before the index file was written.
This could result in a file not being added to the index.

Another option is to maintain a parallel directory tree that contains
symlinks pointing to the main files.
When a new file is added you create a symlink to the real file in the parallel
directory tree.
Then just index the symlink directory to generate the incremental index.

This option has the disadvantage that you need to have a central program that creates
the new files that can also create the symlinks.  But, indexing is quite fast since swish
only has to look at the files that need to be indexed.
When you run full indexing you simply unlink (delete) all the symlinks.

Both of these methods have issues where files could end up in both indexes, or files being left out of an index.
Use of file locks while indexing, and hash lookups during searches can help prevent these problems.

=head2 How do I spider other websites and combine it with my own (filesystem) index?

You can either merge C<-M> two indexes into a single index,
or use C<-f> to specify more than one index while searching.


=head1 Document Info

$Id$

.


